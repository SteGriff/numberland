<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocks</title>
    <style>
      html { background-image: url(https://cdn.glitch.global/bdbab925-c273-47f6-b548-8cef94c1e8a2/numberland-bg.webp?v=1728129309585); }
      .block { width: 4rem; height: 4rem; display: inline-block;}
      .n_1 .block, 
      .n_7 .block:nth-child(7),
      .n_11 .block:nth-child(-n + 1){ 
        background-color: #b00; border-color: #a00;
      }
      .n_2 .block,
      .n_20,
      .n_20 .block,
      .n_7 .block:nth-child(6),
      .n_12 .block:nth-child(-n + 2){
        background-color: #fd0; border-color: #ca0;
      }
      .n_3 .block,
      .n_30,
      .n_30 .block,
      .n_7 .block:nth-child(5),
      .n_13 .block:nth-child(-n + 3){
        background-color: #ff0; border-color: #dd0;
      }
      .n_4 .block,
      .n_40,
      .n_40 .block,
      .n_7 .block:nth-child(4),
      .n_14 .block:nth-child(-n + 4){
        background-color: #0e0; border-color: #0c0;
      }
      .n_5 .block, 
      .n_50,
      .n_50 .block,
      .n_7 .block:nth-child(3),
      .n_15 .block:nth-child(-n + 5){ 
        background-color: #0de; border-color: #0cd; 
      }
      .n_6 .block, 
      .n_7 .block:nth-child(2),
      .n_16 .block:nth-child(-n + 6){ 
        background-color: #909; border-color: #808; 
      }
      .n_7 .block:nth-child(1),
      .n_17 .block:nth-child(-n + 7){
        background-color: #f0f; border-color: #e0e; 
      }
      .n_8 .block,
      .n_18 .block:nth-child(-n + 8){ 
        background-color: #d0d; border-color: #b0b;
      }
      .n_9 .block,
      .n_19 .block:nth-child(-n + 9){ 
        background-color: #aaa; border-color: #999;
      }
      .n_10 .block,
      .n_11 .block,
      .n_12 .block,
      .n_13 .block,
      .n_14 .block,
      .n_15 .block,
      .n_16 .block,
      .n_17 .block,
      .n_18 .block,
      .n_19 .block
      { 
        background-color: #fff; border-color: #a00;
      }
      .n_10 .block:hover { 
        background-color: #b00;
        box-shadow: 0 0 2rem 1rem rgba(255,10,10,0.5);
      }
            
      .entity { border-width: 2px; border-style: solid; }
      .mirror { 
        border: 5px ridge gold; height: 14rem; width: 7rem;
        background: linear-gradient(25deg, rgba(0,128,255,0.2) 0%, rgba(255,255,255,0.3) 45%, rgba(255,255,255,0.3) 55%, rgba(0,128,255,0.2) 100%);
      }
      .abs { position: absolute; }
      .bottom { bottom: 2rem; }
      .top { top: 2rem; }
      .right { right: 2rem; }
      .center { left: 45%; }
      .shine { 
        border-color: #fff; 
        box-shadow: 0 0 4rem 2rem rgba(255,255,128,0.7); }
      .mirror-shine {
        background-color: rgba(255,255,128,0.5);
        box-shadow: 0 0 4rem 2rem rgba(255,255,128,0.7);
      }
      .container {
        display: grid;
      }
      .sun {
        border-radius: 100%;
        background-color: #ff0;
        box-shadow: 0 0 2rem 1rem rgba(255,255,128,0.7);
        cursor: pointer;
      }
      .w_2 {
        grid-template-columns: 4.2rem 4.2rem;
      }
      .w_3 {
        grid-template-columns: 4.2rem 4.2rem 4.2rem;
      }
      .w_4 {
        grid-template-columns: 4.2rem 4.2rem 4.2rem 4.2rem;
      }
      .w_5 {
        grid-template-columns: 4.2rem 4.2rem 4.2rem 4.2rem;
      }
      .draggable { cursor: pointer; }
      .hidden { visibility : hidden; }
    </style>
  </head>
  <body oncontextmenu="return false;">
    <div id="main">
      <div class="sun abs block top right" onclick="makeOne()"></div>
      <div class="draggable mirror abs bottom center" id="0"></div>
      <div class="draggable container abs n_1 w_1 hidden" id="1">
        <div class="block entity"></div>
      </div>
      <div class="draggable container abs n_1 w_1" id="2">
        <div class="block entity"></div>
      </div>
    </div>

    <script>
      const newBlockData = (id) => {
        return {
          id: id,
          initialX: 0,
          initialY: 0,
          currentX: 0,
          currentY: 0,
          xOffset: 0,
          yOffset: 0
        }
      }

      const makeBlockDataIfNone = (id) => {
        if (!blockData[id]) blockData.push(newBlockData(id));
      }
      
      const makeOne = () => {
        dragging = hidden;
        clone(mirror);
        dragging = null;
      }
      
      const initBlock = (b) => {
        console.log("b.id", b.id);
        makeBlockDataIfNone(b.id);
        b.classList.remove("hidden"); // If we cloned from the hidden block
        const thisBlockData = blockData[b.id];
        console.log("thisBlockData", thisBlockData);

        // Listen for the mouse down event
        b.addEventListener("mousedown", function(e) { mouseDown(e, b, thisBlockData) });
        b.addEventListener("touchstart", function(e) { mouseDown(e, b, thisBlockData) });
        b.ondragstart = () => false;
      }

      const mouseDown = (e, b, data) => {
        e.preventDefault();
        if (e.buttons === 2)
          changeShape(b, data); // Right-click
        else
          startDrag(e, b, data); // Other clicks
      };
      
      const startDrag = (e, b, data) => {
        // Record the starting position of the mouse and adjust by any existing offset
        dragging = b;
        const cursorX = e.clientX || e.touches[0].clientX;
        const cursorY = e.clientY || e.touches[0].clientY;
        data.initialX = cursorX - data.xOffset;
        data.initialY = cursorY - data.yOffset;
      };
      
      const changeShape = (b, data) => {
        const width = getWidthValue(b);
        const num = getNumValue(b);
        const nextWidth = (num > width && width < 5)
          ? width + 1
          : 1;
        const currentWidthClass = "w_" + width;
        const newWidthClass = "w_" + nextWidth;
        b.classList.remove(currentWidthClass);
        b.classList.add(newWidthClass);
        console.log("changeShape from", currentWidthClass, "to", newWidthClass);
      }

      const transform = (element, posData) => {
        element.style.transform =
          "translate3d(" + posData.currentX + "px, " + posData.currentY + "px, 0)";
      }

      const isInside = (container, element) => {
        if (container === element) return false;
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        return elementRect.left >= containerRect.left
          && elementRect.right <= containerRect.right
          && elementRect.top >= containerRect.top
          && elementRect.top <= containerRect.bottom;
      }

      const stackedUponBlock = (moving, other) => {
        if (moving === other) return false;
        if (other === mirror) return false;
        const movingRect = moving.getBoundingClientRect();
        const otherRect = other.getBoundingClientRect();
        const isInHorizontalAlignment = (movingRect.left >= otherRect.left && movingRect.left < otherRect.right)
          || (movingRect.right <= otherRect.right && movingRect.right > otherRect.left)
        const isInVerticalAlignment = movingRect.bottom > otherRect.top -10
          && movingRect.bottom < otherRect.top + 20;
        return isInHorizontalAlignment && isInVerticalAlignment
          ? other
          : null;
      }

      const clone = (mirror) => {
        maxId++;
        const newBlockEl = dragging.cloneNode(true);
        console.log("clone", "maxId", maxId);
        newBlockEl.id = maxId;
        initBlock(newBlockEl);
        const oldBlockData = blockData[dragging.id];
        const newBlockData = blockData[maxId];

        newBlockData.currentX = oldBlockData.currentX + 100;
        newBlockData.currentY = oldBlockData.currentY;
        newBlockData.initialX = newBlockData.currentX;
        newBlockData.initialY = newBlockData.currentY;
        newBlockData.xOffset = newBlockData.currentX;
        newBlockData.yOffset = newBlockData.currentY;
        transform(newBlockEl, newBlockData);

        console.log("clone end", "newBlockEl", newBlockEl, "oldBlockEl", dragging, "data", newBlockData);
        main.appendChild(newBlockEl);
      }

      const getNumValue = (el) => +[...el.classList].find(c => c.startsWith("n_")).split("_")[1];
      
      const getWidthValue = (el) => +[...el.classList].find(c => c.startsWith("w_")).split("_")[1];

      const combine = (dragging, stacking) => {
        maxId++;
        makeBlockDataIfNone(maxId);
        const operand1 = getNumValue(dragging);
        const operand2 = getNumValue(stacking);
        const total = operand1 + operand2;
        const newClass = "n_" + total;
        while (stacking.childNodes.length) {
          dragging.appendChild(stacking.firstChild);
        }
        dragging.classList.replace("n_" + operand1, newClass);
        console.log("combine end", dragging, stacking, newClass);
        main.removeChild(stacking);
        stacking = null;
      }

      // Variables to track dragging and position data
      let dragging = null;
      let stacking = null;
      let maxId = 0;
      const blockData = [];
      const main = document.getElementById("main");
      const hidden = document.getElementById("1");
      const mirror = document.getElementsByClassName("mirror")[0];
      const blocks = document.getElementsByClassName("draggable");
      for (const b of blocks)
      {
        if (b.id > maxId) maxId = b.id;
        initBlock(b);
      }

      // Listen for mouse move/up across the entire document
      document.addEventListener("mousemove", function (e) { e.preventDefault(); mouseMove(e) });
      document.addEventListener("touchmove", 
        function (e) { e.preventDefault(); mouseMove(e) },
        {passive: false}
      );
      document.addEventListener("mouseup", function (e) { mouseUp() });
      document.addEventListener("touchend", function (e) { mouseUp() });
      document.addEventListener("touchcancel", function (e) { mouseUp() });
      
      const mouseMove = (e) => {
        if (!dragging) return;
        const bData = blockData[dragging.id];
        const cursorX = e.clientX || e.touches[0].clientX;
        const cursorY = e.clientY || e.touches[0].clientY;
        
        // Calculate the new position of the mouse
        bData.currentX = cursorX - bData.initialX;
        bData.currentY = cursorY - bData.initialY;
        // Update the offset with the new position
        bData.xOffset = bData.currentX;
        bData.yOffset = bData.currentY;
        
        // Move the block to the new position
        transform(dragging, bData);

        if (isInside(mirror, dragging)) {
          mirror.classList.add("mirror-shine");
        } else {
          mirror.classList.remove("mirror-shine");

          for(const b of blocks){
            if (b === dragging) continue;
            stacking = stackedUponBlock(dragging, b);
            if (stacking)
            {
              dragging.classList.add("shine");
              b.classList.add("shine");
              break;
            }
          }

          if (!stacking)
          {
            dragging.classList.remove("shine");
            for (let b of blocks)
              b.classList.remove("shine");
          }
        }
      }
      
      const mouseUp = () => {
        if (!dragging) return;
        // Save the final position
        dragging.initialX = dragging.currentX;
        dragging.initialY = dragging.currentY;
        // Clone if in mirror
        if (isInside(mirror, dragging))
          clone(mirror);
        // Combine if stacking
        if (stacking)
          combine(dragging, stacking);
        // Stop drag
        dragging = null;
        stacking = null;
      }
    </script>
  </body>
</html>