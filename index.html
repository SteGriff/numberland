<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Blocks</title>
    <style>
      .block { width: 3rem; height: 3rem; display: inline-block;}
      .n_1, .n_1 .block, .n_7 .block:nth-child(7) { background-color: #b00; border-color: #a00; }
      .n_2, .n_2 .block, .n_7 .block:nth-child(6) { background-color: #fd0; border-color: #ca0; }
      .n_3, .n_3 .block, .n_7 .block:nth-child(5) { background-color: #ff0; border-color: #dd0; }
      .n_4, .n_4 .block, .n_7 .block:nth-child(4) { background-color: #0e0; border-color: #0c0; }
      .n_5, .n_5 .block, .n_7 .block:nth-child(3) { background-color: #0ee; border-color: #0dd; }
      .n_6, .n_6 .block, .n_7 .block:nth-child(2) { background-color: #b0b; border-color: #a0a; }
      .n_7, .n_7 .block:nth-child(1) { background-color: #f0f; border-color: #e0e; }
      .entity { border-width: 2px; border-style: solid; }
      .mirror { border: 5px ridge gold; height: 9rem; width: 5rem; background-color: rgba(0,128,255,0.1)}
      .abs { position: absolute; }
      .bottom { bottom: 5rem; }
      .center { left: 45%; }
      .shine { border-color: #ddd; box-shadow: 0 0 50px 15px #eee; }
      .flex { display: flex; }
      .flex-col { flex-direction: column; }
      .draggable { cursor: pointer; }
    </style>
  </head>
  <body>
    <div id="main">
      <div class="draggable mirror abs bottom center" id="0"></div>
      <div class="draggable container abs entity flex flex-col n_1" id="1">
        <div class="block entity"></div>
      </div>
    </div>

    <script>
      const newBlockData = (id) => {
        return {
          id: id,
          initialX: 0,
          initialY: 0,
          currentX: 0,
          currentY: 0,
          xOffset: 0,
          yOffset: 0
        }
      }
      
      const makeBlockDataIfNone = (id) => {
        if (!blockData[id]) blockData.push(newBlockData(id));
      }
      
      const initBlock = (b) => {
        console.log("b.id", b.id);
        makeBlockDataIfNone(b.id);
        const thisBlockData = blockData[b.id];
        console.log("thisBlockData", thisBlockData);
        
        // Listen for the mouse down event
        b.addEventListener("mousedown", function (e) {
          // Record the starting position of the mouse and adjust by any existing offset
          dragging = b;
          thisBlockData.initialX = e.clientX - thisBlockData.xOffset;
          thisBlockData.initialY = e.clientY - thisBlockData.yOffset;
        });
        b.ondragstart = () => false;
      }
      
      const transform = (element, posData) => {
        element.style.transform = 
          "translate3d(" + posData.currentX + "px, " + posData.currentY + "px, 0)";
      }
      
      const isInside = (container, element) => {
        if (container === element) return false;
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        return elementRect.left >= containerRect.left 
          && elementRect.right <= containerRect.right 
          && elementRect.top >= containerRect.top; 
          //&& elementRect.bottom <= containerRect.bottom;
      }
      
      const stackedUponBlock = (moving, other) => {
        if (moving === other) return false;
        const movingRect = moving.getBoundingClientRect();
        const otherRect = other.getBoundingClientRect();
        const isInHorizontalAlignment = (movingRect.left >= otherRect.left && movingRect.left < otherRect.right)
          || (movingRect.right <= otherRect.right && movingRect.right > otherRect.left)
        const isInVerticalAlignment = movingRect.bottom > otherRect.top
          && movingRect.bottom < otherRect.top + 20;
        return isInHorizontalAlignment && isInVerticalAlignment
          ? other
          : null;
      }
      
      const clone = (mirror) => {
        maxId++;
        const newBlockEl = dragging.cloneNode(true);
        console.log("clone", "maxId", maxId, "newBlockEl", newBlockEl, "oldBlockEl");
        newBlockEl.id = maxId;
        initBlock(newBlockEl);
        const oldBlockData = blockData[dragging.id];
        const newBlockData = blockData[maxId];
        
        newBlockData.currentX = oldBlockData.currentX + 100;
        newBlockData.currentY = oldBlockData.currentY;
        newBlockData.initialX = newBlockData.currentX;
        newBlockData.initialY = newBlockData.currentY;
        newBlockData.xOffset = newBlockData.currentX;
        newBlockData.yOffset = newBlockData.currentY;
        transform(newBlockEl, newBlockData);
        
        console.log("clone end", "newBlockEl", newBlockEl, "oldBlockEl", dragging, "data", newBlockData);
        main.appendChild(newBlockEl);
      }
      
      const getNumValue = (el) => +[...el.classList].find(c => c.startsWith("n_")).split("_")[1];
      
      const combine = (dragging, stacking) => {
        maxId++;
        makeBlockDataIfNone(maxId);
        const operand1 = getNumValue(dragging);
        const operand2 = getNumValue(stacking);
        const total = operand1 + operand2;
        const newClass = "n_" + total;
        console.log("combine", dragging, stacking, newClass);
        while (stacking.childNodes.length) {
          dragging.appendChild(stacking.firstChild);
        }
        dragging.classList.replace("n_" + operand1, newClass);
        console.log("combine end", dragging, stacking);
        main.removeChild(stacking);
        stacking = null;
      }
      
      // Variables to track dragging and position data
      let dragging = null;
      let stacking = null;
      let maxId = 0;
      const blockData = [];
      const main = document.getElementById("main");
      const mirror = document.getElementsByClassName("mirror")[0];
      const blocks = document.getElementsByClassName("draggable");
      for (const b of blocks)
      {
        if (b.id > maxId) maxId = b.id;
        initBlock(b);
      }
      
      // Listen for mouse movement across the entire document
      document.addEventListener("mousemove", function (e) {
        e.preventDefault
        if (!dragging) return;
        const bData = blockData[dragging.id];
        
        // Calculate the new position of the mouse
        bData.currentX = e.clientX - bData.initialX;
        bData.currentY = e.clientY - bData.initialY;
        // Update the offset with the new position
        bData.xOffset = bData.currentX;
        bData.yOffset = bData.currentY;
        // Move the block to the new position
        transform(dragging, bData);
        
        if (isInside(mirror, dragging)) {
          mirror.style.backgroundColor = "rgba(255,255,128,0.5)";
          mirror.style.boxShadow= "0 0 50px 15px rgba(255,255,128,0.5)";
        } else {
          mirror.style.backgroundColor = "";
          mirror.style.boxShadow= "";
          
          for(const b of blocks){
            if (b === dragging) continue;
            stacking = stackedUponBlock(dragging, b);
            if (stacking)
            {
              dragging.classList.add("shine");
              b.classList.add("shine");
              break;
            }
          }
          
          if (!stacking)
          {
            dragging.classList.remove("shine");
            for (let b of blocks)
              b.classList.remove("shine");
          }
        }
      });

      // Listen for the mouse up event across the entire document
      document.addEventListener("mouseup", function () {
        if (!dragging) return;
        // Save the final position
        dragging.initialX = dragging.currentX;
        dragging.initialY = dragging.currentY;
        // Clone if in mirror
        if (isInside(mirror, dragging))
          clone(mirror);
        // Combine if stacking
        if (stacking)
          combine(dragging, stacking);
        // Stop drag
        dragging = null;
      });
    </script>
  </body>
</html>