<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blocks</title>
    <style>
      .block { width: 4rem; height: 4rem; display: inline-block;}
      .n_1, .n_1 .block, .n_7 .block:nth-child(7) { background-color: #b00; border-color: #a00; }
      .n_2, .n_2 .block, .n_7 .block:nth-child(6) { background-color: #fd0; border-color: #ca0; }
      .n_3, .n_3 .block, .n_7 .block:nth-child(5) { background-color: #ff0; border-color: #dd0; }
      .n_4, .n_4 .block, .n_7 .block:nth-child(4) { background-color: #0e0; border-color: #0c0; }
      .n_5, .n_5 .block, .n_7 .block:nth-child(3) { background-color: #0de; border-color: #0cd; }
      .n_6, .n_6 .block, .n_7 .block:nth-child(2) { background-color: #909; border-color: #808; }
      .n_7, .n_7 .block:nth-child(1) { background-color: #f0f; border-color: #e0e; }
      .n_8, .n_8 .block { background-color: #d0d; border-color: #b0b; }
      .n_9, .n_9 .block { background-color: #aaa; border-color: #999; }
      .n_10, .n_10 .block { background-color: #fff; border-color: #a00; }
      .entity { border-width: 2px; border-style: solid; }
      .mirror { border: 5px ridge gold; height: 14rem; width: 7rem; background-color: rgba(0,128,255,0.1)}
      .abs { position: absolute; }
      .bottom { bottom: 5rem; }
      .center { left: 45%; }
      .shine { border-color: #fff; box-shadow: 0 0 60px 30px rgba(255,255,128,0.7); }
      .flex { display: flex; }
      .flex-col { flex-direction: column; }
      .draggable { cursor: pointer; }
    </style>
  </head>
  <body>
    <div id="main">
      <div class="draggable mirror abs bottom center" id="0"></div>
      <div class="draggable container abs entity flex flex-col n_1" id="1">
        <div class="block entity"></div>
      </div>
    </div>

    <script>
      const newBlockData = (id) => {
        return {
          id: id,
          initialX: 0,
          initialY: 0,
          currentX: 0,
          currentY: 0,
          xOffset: 0,
          yOffset: 0
        }
      }

      const makeBlockDataIfNone = (id) => {
        if (!blockData[id]) blockData.push(newBlockData(id));
      }

      const initBlock = (b) => {
        console.log("b.id", b.id);
        makeBlockDataIfNone(b.id);
        const thisBlockData = blockData[b.id];
        console.log("thisBlockData", thisBlockData);

        // Listen for the mouse down event
        b.addEventListener("mousedown", function(e) { mouseDown(e, b, thisBlockData) });
        b.addEventListener("touchstart", function(e) { mouseDown(e, b, thisBlockData) });
        b.ondragstart = () => false;
      }

      const mouseDown = (e, b, data) => {
        // Record the starting position of the mouse and adjust by any existing offset
        dragging = b;
        const cursorX = e.clientX || e.touches[0].clientX;
        const cursorY = e.clientY || e.touches[0].clientY;
        data.initialX = cursorX - data.xOffset;
        data.initialY = cursorY - data.yOffset;
      };

      const transform = (element, posData) => {
        element.style.transform =
          "translate3d(" + posData.currentX + "px, " + posData.currentY + "px, 0)";
      }

      const isInside = (container, element) => {
        if (container === element) return false;
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        return elementRect.left >= containerRect.left
          && elementRect.right <= containerRect.right
          && elementRect.top >= containerRect.top
          && elementRect.top <= containerRect.bottom;
      }

      const stackedUponBlock = (moving, other) => {
        if (moving === other) return false;
        const movingRect = moving.getBoundingClientRect();
        const otherRect = other.getBoundingClientRect();
        const isInHorizontalAlignment = (movingRect.left >= otherRect.left && movingRect.left < otherRect.right)
          || (movingRect.right <= otherRect.right && movingRect.right > otherRect.left)
        const isInVerticalAlignment = movingRect.bottom > otherRect.top -10
          && movingRect.bottom < otherRect.top + 20;
        return isInHorizontalAlignment && isInVerticalAlignment
          ? other
          : null;
      }

      const clone = (mirror) => {
        maxId++;
        const newBlockEl = dragging.cloneNode(true);
        console.log("clone", "maxId", maxId);
        newBlockEl.id = maxId;
        initBlock(newBlockEl);
        const oldBlockData = blockData[dragging.id];
        const newBlockData = blockData[maxId];

        newBlockData.currentX = oldBlockData.currentX + 100;
        newBlockData.currentY = oldBlockData.currentY;
        newBlockData.initialX = newBlockData.currentX;
        newBlockData.initialY = newBlockData.currentY;
        newBlockData.xOffset = newBlockData.currentX;
        newBlockData.yOffset = newBlockData.currentY;
        transform(newBlockEl, newBlockData);

        console.log("clone end", "newBlockEl", newBlockEl, "oldBlockEl", dragging, "data", newBlockData);
        main.appendChild(newBlockEl);
      }

      const getNumValue = (el) => +[...el.classList].find(c => c.startsWith("n_")).split("_")[1];

      const combine = (dragging, stacking) => {
        maxId++;
        makeBlockDataIfNone(maxId);
        const operand1 = getNumValue(dragging);
        const operand2 = getNumValue(stacking);
        const total = operand1 + operand2;
        const newClass = "n_" + total;
        while (stacking.childNodes.length) {
          dragging.appendChild(stacking.firstChild);
        }
        dragging.classList.replace("n_" + operand1, newClass);
        console.log("combine end", dragging, stacking, newClass);
        main.removeChild(stacking);
        stacking = null;
      }

      // Variables to track dragging and position data
      let dragging = null;
      let stacking = null;
      let maxId = 0;
      const blockData = [];
      const main = document.getElementById("main");
      const mirror = document.getElementsByClassName("mirror")[0];
      const blocks = document.getElementsByClassName("draggable");
      for (const b of blocks)
      {
        if (b.id > maxId) maxId = b.id;
        initBlock(b);
      }

      // Listen for mouse move/up across the entire document
      document.addEventListener("mousemove", function (e) { e.preventDefault(); mouseMove(e) });
      document.addEventListener("touchmove", 
        function (e) { e.preventDefault(); mouseMove(e) },
        {passive: false}
      );
      document.addEventListener("mouseup", function (e) { mouseUp() });
      document.addEventListener("touchend", function (e) { mouseUp() });
      document.addEventListener("touchcancel", function (e) { mouseUp() });
      
      const mouseMove = (e) => {
        if (!dragging) return;
        const bData = blockData[dragging.id];
        const cursorX = e.clientX || e.touches[0].clientX;
        const cursorY = e.clientY || e.touches[0].clientY;
        
        // Calculate the new position of the mouse
        bData.currentX = cursorX - bData.initialX;
        bData.currentY = cursorY - bData.initialY;
        // Update the offset with the new position
        bData.xOffset = bData.currentX;
        bData.yOffset = bData.currentY;
        
        // Move the block to the new position
        transform(dragging, bData);

        if (isInside(mirror, dragging)) {
          mirror.style.backgroundColor = "rgba(255,255,128,0.5)";
          mirror.style.boxShadow= "0 0 60px 30px rgba(255,255,128,0.7)";
        } else {
          mirror.style.backgroundColor = "";
          mirror.style.boxShadow= "";

          for(const b of blocks){
            if (b === dragging) continue;
            stacking = stackedUponBlock(dragging, b);
            if (stacking)
            {
              dragging.classList.add("shine");
              b.classList.add("shine");
              break;
            }
          }

          if (!stacking)
          {
            dragging.classList.remove("shine");
            for (let b of blocks)
              b.classList.remove("shine");
          }
        }
      }
      
      const mouseUp = () => {
        if (!dragging) return;
        // Save the final position
        dragging.initialX = dragging.currentX;
        dragging.initialY = dragging.currentY;
        // Clone if in mirror
        if (isInside(mirror, dragging))
          clone(mirror);
        // Combine if stacking
        if (stacking)
          combine(dragging, stacking);
        // Stop drag
        dragging = null;
      }
    </script>
  </body>
</html>